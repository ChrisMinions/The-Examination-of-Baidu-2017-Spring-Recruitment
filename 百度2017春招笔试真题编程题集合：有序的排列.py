'''
[编程题] 有趣的排序
时间限制：1秒
空间限制：32768K
度度熊有一个N个数的数组，他想将数组从小到大 排好序，但是萌萌的度度熊只会下面这个操作：
任取数组中的一个数然后将它放置在数组的最后一个位置。
问最少操作多少次可以使得数组从小到大有序？ 
输入描述:
首先输入一个正整数N，接下来的一行输入N个整数。(N <= 50, 每个数的绝对值小于等于1000)


输出描述:
输出一个整数表示最少的操作次数。

输入例子1:
4
19 7 8 25

输出例子1:
2
'''

'''
解题思路：仔细审题，理解问题本质
  仔细审题后，我们发现这道题的本质就是：找出第一个不按规则排序的数字！
  例如，在 1,4,2,3,5  这五个数中，第二小的数字2在最小的数字1后面，第三小的数字3在2后面，然后第四小的数字4却不在3后面
  这就意味着，数字4和比它大的数字都需要操作一次，在本例中需要把4操作一次，然后把5操作一次，共需要操作2次
  在 2,1,3,4,5 中，第一个不按规则排序的数字是2，所有2以及比二大的数字都需要操作一次，共需要操作4次
  当然，这种算法能工作还有一个重要前提：整个数组中没有重复的元素，否则的话，这个算法便不适用了
'''

'''
代码运行结果：
答案正确:恭喜！您提交的程序通过了所有的测试用例
'''

n = int(input())
digs = [int(each) for each in input().split()]

min_dig = min(digs)
min_dig_index = digs.index(min_dig)

ordered_digs = sorted(digs)

for i in range(1, n):
    temp_index = digs.index(ordered_digs[i])
    if temp_index < min_dig_index:
        break
    else:
        min_dig_index = digs.index(ordered_digs[i])

if digs == ordered_digs:
    print(0)
else:
    print(n - i)
